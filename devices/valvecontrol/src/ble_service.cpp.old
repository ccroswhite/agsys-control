/**
 * @file ble_service.cpp
 * @brief BLE Service implementation for Valve Controller
 */

#include "ble_service.h"
#include "can_bus.h"
#include <Adafruit_FRAM_SPI.h>
#include <Arduino.h>

// Import needed config values without full config.h (avoids CAN_SPEED conflict)
#ifndef FIRMWARE_VERSION_MAJOR
#define FIRMWARE_VERSION_MAJOR      1
#define FIRMWARE_VERSION_MINOR      0
#define FIRMWARE_VERSION_PATCH      0
#define DEVICE_TYPE                 0x02
#define BLE_DEVICE_NAME             "ValveCtrl"
#endif

#if !defined(DEBUG_MODE)
#define DEBUG_MODE 1
#endif

#if DEBUG_MODE
    #define DEBUG_PRINT(x)          Serial.print(x)
    #define DEBUG_PRINTLN(x)        Serial.println(x)
    #define DEBUG_PRINTF(...)       Serial.printf(__VA_ARGS__)
#else
    #define DEBUG_PRINT(x)
    #define DEBUG_PRINTLN(x)
    #define DEBUG_PRINTF(...)
#endif

// External FRAM instance (defined in main.cpp)
extern Adafruit_FRAM_SPI fram;

// FRAM address for PIN storage
#define FRAM_ADDR_BLE_PIN       0x00F0  // 4 bytes for PIN

// BLE Service and Characteristics
static BLEService valveService(BLE_UUID_VALVE_SERVICE);
static BLECharacteristic deviceInfoChar(BLE_UUID_DEVICE_INFO);
static BLECharacteristic valveCommandChar(BLE_UUID_VALVE_COMMAND);
static BLECharacteristic valveStatusChar(BLE_UUID_VALVE_STATUS);
static BLECharacteristic canDiscoveryChar(BLE_UUID_CAN_DISCOVERY);
static BLECharacteristic actuatorListChar(BLE_UUID_ACTUATOR_LIST);
static BLECharacteristic pinAuthChar(BLE_UUID_PIN_AUTH);
static BLECharacteristic pinChangeChar(BLE_UUID_PIN_CHANGE);

// Discovery state
static volatile uint8_t discoveryStatus = BLE_DISCOVERY_IDLE;
static volatile bool discoveryRequested = false;
static uint8_t discoveredCount = 0;

// Authentication state
static uint8_t storedPin[BLE_PIN_LENGTH] = {'1', '2', '3', '4'};  // Default PIN
static bool isAuthenticated = false;
static uint32_t authTime = 0;
static uint8_t failedAttempts = 0;
static uint32_t lockoutStartTime = 0;

// Forward declarations
static void onValveCommandWrite(uint16_t conn_hdl, BLECharacteristic* chr, uint8_t* data, uint16_t len);
static void onCanDiscoveryWrite(uint16_t conn_hdl, BLECharacteristic* chr, uint8_t* data, uint16_t len);
static void onPinAuthWrite(uint16_t conn_hdl, BLECharacteristic* chr, uint8_t* data, uint16_t len);
static void onPinChangeWrite(uint16_t conn_hdl, BLECharacteristic* chr, uint8_t* data, uint16_t len);
static void onConnect(uint16_t conn_handle);
static void onDisconnect(uint16_t conn_handle, uint8_t reason);
static bool checkAuth(void);
static void updateAuthStatus(void);

void ble_init(void) {
    DEBUG_PRINTLN("BLE: Initializing...");
    
    // Initialize Bluefruit
    Bluefruit.begin();
    Bluefruit.setName(BLE_DEVICE_NAME);
    Bluefruit.setTxPower(4);  // 4 dBm
    
    // Set callbacks
    Bluefruit.Periph.setConnectCallback(onConnect);
    Bluefruit.Periph.setDisconnectCallback(onDisconnect);
    
    // Setup Valve Service
    valveService.begin();
    
    // Device Info Characteristic (Read only)
    // Format: [UID 8 bytes][FW Major][FW Minor][FW Patch][Device Type]
    deviceInfoChar.setProperties(CHR_PROPS_READ);
    deviceInfoChar.setPermission(SECMODE_OPEN, SECMODE_NO_ACCESS);
    deviceInfoChar.setFixedLen(12);
    deviceInfoChar.begin();
    
    // Set device info data
    uint8_t deviceInfo[12];
    uint32_t deviceId0 = NRF_FICR->DEVICEID[0];
    uint32_t deviceId1 = NRF_FICR->DEVICEID[1];
    deviceInfo[0] = (deviceId0 >> 0) & 0xFF;
    deviceInfo[1] = (deviceId0 >> 8) & 0xFF;
    deviceInfo[2] = (deviceId0 >> 16) & 0xFF;
    deviceInfo[3] = (deviceId0 >> 24) & 0xFF;
    deviceInfo[4] = (deviceId1 >> 0) & 0xFF;
    deviceInfo[5] = (deviceId1 >> 8) & 0xFF;
    deviceInfo[6] = (deviceId1 >> 16) & 0xFF;
    deviceInfo[7] = (deviceId1 >> 24) & 0xFF;
    deviceInfo[8] = FIRMWARE_VERSION_MAJOR;
    deviceInfo[9] = FIRMWARE_VERSION_MINOR;
    deviceInfo[10] = FIRMWARE_VERSION_PATCH;
    deviceInfo[11] = DEVICE_TYPE;
    deviceInfoChar.write(deviceInfo, sizeof(deviceInfo));
    
    // Valve Command Characteristic (Write only)
    // Format: [Command][Address][Duration MSB][Duration LSB]
    valveCommandChar.setProperties(CHR_PROPS_WRITE);
    valveCommandChar.setPermission(SECMODE_NO_ACCESS, SECMODE_OPEN);
    valveCommandChar.setWriteCallback(onValveCommandWrite);
    valveCommandChar.setMaxLen(4);
    valveCommandChar.begin();
    
    // Valve Status Characteristic (Read + Notify)
    // Format: [Address][State][Current MSB][Current LSB][Flags]
    valveStatusChar.setProperties(CHR_PROPS_READ | CHR_PROPS_NOTIFY);
    valveStatusChar.setPermission(SECMODE_OPEN, SECMODE_NO_ACCESS);
    valveStatusChar.setMaxLen(5);
    valveStatusChar.begin();
    
    // CAN Discovery Characteristic (Read + Write)
    // Write: [Command] - 0x01 = start discovery
    // Read: [Status][Count] - status and number of actuators found
    canDiscoveryChar.setProperties(CHR_PROPS_READ | CHR_PROPS_WRITE | CHR_PROPS_NOTIFY);
    canDiscoveryChar.setPermission(SECMODE_OPEN, SECMODE_OPEN);
    canDiscoveryChar.setWriteCallback(onCanDiscoveryWrite);
    canDiscoveryChar.setMaxLen(2);
    canDiscoveryChar.begin();
    
    // Set initial discovery status
    uint8_t discStatus[2] = {BLE_DISCOVERY_IDLE, 0};
    canDiscoveryChar.write(discStatus, 2);
    
    // Actuator List Characteristic (Read only)
    // Format: [Count][ActuatorInfo 0][ActuatorInfo 1]...
    // Each ActuatorInfo is 11 bytes (address + 8-byte UID + state + flags)
    // Max ~18 actuators per read (MTU limit)
    actuatorListChar.setProperties(CHR_PROPS_READ);
    actuatorListChar.setPermission(SECMODE_OPEN, SECMODE_NO_ACCESS);
    actuatorListChar.setMaxLen(200);  // 1 + 18*11 = 199 bytes max
    actuatorListChar.begin();
    
    // PIN Authentication Characteristic (Read + Write)
    // Write: [PIN 4 bytes] - authenticate with PIN
    // Read: [Status] - authentication status
    pinAuthChar.setProperties(CHR_PROPS_READ | CHR_PROPS_WRITE);
    pinAuthChar.setPermission(SECMODE_OPEN, SECMODE_OPEN);
    pinAuthChar.setWriteCallback(onPinAuthWrite);
    pinAuthChar.setMaxLen(BLE_PIN_LENGTH);
    pinAuthChar.begin();
    
    // Set initial auth status
    uint8_t authStatus = BLE_AUTH_NOT_AUTHENTICATED;
    pinAuthChar.write(&authStatus, 1);
    
    // PIN Change Characteristic (Write only, requires auth)
    // Write: [Old PIN 4 bytes][New PIN 4 bytes]
    pinChangeChar.setProperties(CHR_PROPS_WRITE);
    pinChangeChar.setPermission(SECMODE_NO_ACCESS, SECMODE_OPEN);
    pinChangeChar.setWriteCallback(onPinChangeWrite);
    pinChangeChar.setMaxLen(BLE_PIN_LENGTH * 2);
    pinChangeChar.begin();
    
    // Load PIN from FRAM
    ble_loadPin();
    
    DEBUG_PRINTLN("BLE: Service initialized");
}

void ble_startAdvertising(void) {
    // Configure advertising
    Bluefruit.Advertising.addFlags(BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE);
    Bluefruit.Advertising.addTxPower();
    Bluefruit.Advertising.addService(valveService);
    Bluefruit.Advertising.addName();
    
    // Set advertising parameters
    Bluefruit.Advertising.restartOnDisconnect(true);
    Bluefruit.Advertising.setInterval(160, 244);  // 100-152.5 ms
    Bluefruit.Advertising.setFastTimeout(30);     // 30 seconds fast mode
    
    Bluefruit.Advertising.start(0);  // 0 = advertise forever
    
    DEBUG_PRINTLN("BLE: Advertising started");
}

void ble_stopAdvertising(void) {
    Bluefruit.Advertising.stop();
    DEBUG_PRINTLN("BLE: Advertising stopped");
}

bool ble_isConnected(void) {
    return Bluefruit.connected();
}

void ble_process(void) {
    // Handle pending discovery request
    if (discoveryRequested) {
        discoveryRequested = false;
        discoveryStatus = BLE_DISCOVERY_IN_PROGRESS;
        
        // Update characteristic to show in-progress
        uint8_t discStatus[2] = {BLE_DISCOVERY_IN_PROGRESS, 0};
        canDiscoveryChar.write(discStatus, 2);
        if (Bluefruit.connected()) {
            canDiscoveryChar.notify(discStatus, 2);
        }
        
        DEBUG_PRINTLN("BLE: Starting CAN discovery...");
        
        // Trigger CAN bus discovery
        canbus_discover_all();
        
        // Wait for responses (64 actuators * 5ms stagger = 320ms max)
        delay(500);
        
        // Process CAN messages
        canbus_process();
        
        // Get results
        discoveredCount = canbus_get_online_count();
        discoveryStatus = BLE_DISCOVERY_COMPLETE;
        
        DEBUG_PRINTF("BLE: Discovery complete, found %d actuators\n", discoveredCount);
        
        // Update discovery characteristic
        discStatus[0] = BLE_DISCOVERY_COMPLETE;
        discStatus[1] = discoveredCount;
        canDiscoveryChar.write(discStatus, 2);
        if (Bluefruit.connected()) {
            canDiscoveryChar.notify(discStatus, 2);
        }
        
        // Update actuator list characteristic
        ble_setDiscoveryResults(discoveredCount);
    }
}

void ble_updateActuatorStatus(uint8_t address, uint8_t state, uint16_t currentMa) {
    uint8_t status[5];
    status[0] = address;
    status[1] = state;
    status[2] = (currentMa >> 8) & 0xFF;
    status[3] = currentMa & 0xFF;
    status[4] = 0;  // Flags
    
    valveStatusChar.write(status, sizeof(status));
    
    if (Bluefruit.connected()) {
        valveStatusChar.notify(status, sizeof(status));
    }
}

void ble_setDiscoveryResults(uint8_t count) {
    // Build actuator list
    uint8_t buffer[200];
    buffer[0] = 0;  // Count placeholder
    
    uint8_t idx = 0;
    uint8_t* ptr = buffer + 1;
    
    for (uint8_t addr = ACTUATOR_ADDR_MIN; addr <= ACTUATOR_ADDR_MAX && idx < 18; addr++) {
        ActuatorStatus* status = canbus_get_actuator(addr);
        if (status && status->online && status->uid_known) {
            BleActuatorInfo* info = (BleActuatorInfo*)ptr;
            info->address = addr;
            memcpy(info->uid, status->uid, 8);
            info->state = status->status_flags;
            info->flags = 0;
            
            ptr += sizeof(BleActuatorInfo);
            idx++;
        }
    }
    
    buffer[0] = idx;
    size_t len = 1 + (idx * sizeof(BleActuatorInfo));
    
    actuatorListChar.write(buffer, len);
    
    DEBUG_PRINTF("BLE: Actuator list updated with %d entries\n", idx);
}

// Callback: Valve command received
static void onValveCommandWrite(uint16_t conn_hdl, BLECharacteristic* chr, uint8_t* data, uint16_t len) {
    (void)conn_hdl;
    (void)chr;
    
    // Require authentication for valve commands
    if (!checkAuth()) {
        DEBUG_PRINTLN("BLE: Valve command rejected - not authenticated");
        return;
    }
    
    if (len < 2) {
        DEBUG_PRINTLN("BLE: Invalid valve command (too short)");
        return;
    }
    
    uint8_t command = data[0];
    uint8_t address = data[1];
    uint16_t duration = 0;
    if (len >= 4) {
        duration = (data[2] << 8) | data[3];
    }
    
    DEBUG_PRINTF("BLE: Valve command: cmd=%d, addr=%d, dur=%d\n", command, address, duration);
    
    bool success = false;
    uint8_t resultState = 0;
    
    switch (command) {
        case BLE_CMD_VALVE_OPEN:
            success = canbus_open_valve(address);
            resultState = success ? 0x02 : 0xFF;  // OPEN or ERROR
            break;
            
        case BLE_CMD_VALVE_CLOSE:
            success = canbus_close_valve(address);
            resultState = success ? 0x04 : 0xFF;  // CLOSED or ERROR
            break;
            
        case BLE_CMD_VALVE_STOP:
            success = canbus_stop_valve(address);
            resultState = 0x00;  // UNKNOWN
            break;
            
        case BLE_CMD_VALVE_QUERY:
            resultState = canbus_get_valve_state(address);
            success = (resultState != 0xFF);
            break;
            
        case BLE_CMD_EMERGENCY_CLOSE:
            canbus_emergency_close_all();
            success = true;
            resultState = 0x04;  // CLOSED
            break;
            
        default:
            DEBUG_PRINTF("BLE: Unknown valve command: %d\n", command);
            return;
    }
    
    // Update status characteristic with result
    ble_updateActuatorStatus(address, resultState, canbus_get_motor_current(address));
}

// Callback: CAN discovery command received
static void onCanDiscoveryWrite(uint16_t conn_hdl, BLECharacteristic* chr, uint8_t* data, uint16_t len) {
    (void)conn_hdl;
    (void)chr;
    
    // Require authentication for discovery commands
    if (!checkAuth()) {
        DEBUG_PRINTLN("BLE: Discovery rejected - not authenticated");
        return;
    }
    
    if (len < 1) {
        return;
    }
    
    uint8_t command = data[0];
    
    switch (command) {
        case BLE_CMD_DISCOVER_START:
            if (discoveryStatus != BLE_DISCOVERY_IN_PROGRESS) {
                DEBUG_PRINTLN("BLE: Discovery requested");
                discoveryRequested = true;
            } else {
                DEBUG_PRINTLN("BLE: Discovery already in progress");
            }
            break;
            
        case BLE_CMD_DISCOVER_STATUS:
            // Just read the current status (already in characteristic)
            DEBUG_PRINTF("BLE: Discovery status query: %d, count=%d\n", 
                        discoveryStatus, discoveredCount);
            break;
            
        default:
            DEBUG_PRINTF("BLE: Unknown discovery command: %d\n", command);
            break;
    }
}

// Callback: Client connected
static void onConnect(uint16_t conn_handle) {
    (void)conn_handle;
    DEBUG_PRINTLN("BLE: Client connected");
    
    // Reset authentication for new connection
    isAuthenticated = false;
    updateAuthStatus();
    
    // Reset discovery status for new connection
    discoveryStatus = BLE_DISCOVERY_IDLE;
    uint8_t discStatus[2] = {BLE_DISCOVERY_IDLE, discoveredCount};
    canDiscoveryChar.write(discStatus, 2);
}

// Callback: Client disconnected
static void onDisconnect(uint16_t conn_handle, uint8_t reason) {
    (void)conn_handle;
    (void)reason;
    DEBUG_PRINTLN("BLE: Client disconnected");
    
    // Clear authentication on disconnect
    isAuthenticated = false;
}

// Callback: PIN authentication attempt
static void onPinAuthWrite(uint16_t conn_hdl, BLECharacteristic* chr, uint8_t* data, uint16_t len) {
    (void)conn_hdl;
    (void)chr;
    
    // Check for lockout
    if (failedAttempts >= BLE_PIN_MAX_ATTEMPTS) {
        if (millis() - lockoutStartTime < BLE_PIN_LOCKOUT_MS) {
            DEBUG_PRINTLN("BLE: Auth rejected - locked out");
            uint8_t status = BLE_AUTH_LOCKED_OUT;
            pinAuthChar.write(&status, 1);
            return;
        } else {
            // Lockout expired
            failedAttempts = 0;
        }
    }
    
    if (len != BLE_PIN_LENGTH) {
        DEBUG_PRINTLN("BLE: Invalid PIN length");
        uint8_t status = BLE_AUTH_FAILED;
        pinAuthChar.write(&status, 1);
        return;
    }
    
    // Compare PIN
    bool match = true;
    for (int i = 0; i < BLE_PIN_LENGTH; i++) {
        if (data[i] != storedPin[i]) {
            match = false;
            break;
        }
    }
    
    if (match) {
        DEBUG_PRINTLN("BLE: Authentication successful");
        isAuthenticated = true;
        authTime = millis();
        failedAttempts = 0;
        updateAuthStatus();
    } else {
        DEBUG_PRINTLN("BLE: Authentication failed - wrong PIN");
        failedAttempts++;
        if (failedAttempts >= BLE_PIN_MAX_ATTEMPTS) {
            lockoutStartTime = millis();
            DEBUG_PRINTLN("BLE: Too many failed attempts - locked out");
            uint8_t status = BLE_AUTH_LOCKED_OUT;
            pinAuthChar.write(&status, 1);
        } else {
            uint8_t status = BLE_AUTH_FAILED;
            pinAuthChar.write(&status, 1);
        }
    }
}

// Callback: PIN change request
static void onPinChangeWrite(uint16_t conn_hdl, BLECharacteristic* chr, uint8_t* data, uint16_t len) {
    (void)conn_hdl;
    (void)chr;
    
    // Require authentication to change PIN
    if (!checkAuth()) {
        DEBUG_PRINTLN("BLE: PIN change rejected - not authenticated");
        return;
    }
    
    if (len != BLE_PIN_LENGTH * 2) {
        DEBUG_PRINTLN("BLE: Invalid PIN change data length");
        return;
    }
    
    // Verify old PIN
    bool oldMatch = true;
    for (int i = 0; i < BLE_PIN_LENGTH; i++) {
        if (data[i] != storedPin[i]) {
            oldMatch = false;
            break;
        }
    }
    
    if (!oldMatch) {
        DEBUG_PRINTLN("BLE: PIN change failed - old PIN incorrect");
        return;
    }
    
    // Set new PIN
    memcpy(storedPin, data + BLE_PIN_LENGTH, BLE_PIN_LENGTH);
    
    // Save to FRAM
    ble_setPin(storedPin);
    
    DEBUG_PRINTLN("BLE: PIN changed successfully");
}

// Check if currently authenticated (with timeout)
static bool checkAuth(void) {
    if (!isAuthenticated) {
        return false;
    }
    
    // Check for session timeout
    if (millis() - authTime > BLE_AUTH_TIMEOUT_MS) {
        DEBUG_PRINTLN("BLE: Session expired");
        isAuthenticated = false;
        updateAuthStatus();
        return false;
    }
    
    return true;
}

// Update authentication status characteristic
static void updateAuthStatus(void) {
    uint8_t status = isAuthenticated ? BLE_AUTH_AUTHENTICATED : BLE_AUTH_NOT_AUTHENTICATED;
    pinAuthChar.write(&status, 1);
}

// Public API: Check authentication status
bool ble_isAuthenticated(void) {
    return checkAuth();
}

// Public API: Set PIN and save to FRAM
void ble_setPin(const uint8_t* pin) {
    memcpy(storedPin, pin, BLE_PIN_LENGTH);
    fram.write(FRAM_ADDR_BLE_PIN, (uint8_t*)storedPin, BLE_PIN_LENGTH);
    DEBUG_PRINTLN("BLE: PIN saved to FRAM");
}

// Public API: Load PIN from FRAM
void ble_loadPin(void) {
    uint8_t loadedPin[BLE_PIN_LENGTH];
    fram.read(FRAM_ADDR_BLE_PIN, loadedPin, BLE_PIN_LENGTH);
    
    // Check if PIN is valid (not all 0xFF which indicates uninitialized FRAM)
    bool valid = false;
    for (int i = 0; i < BLE_PIN_LENGTH; i++) {
        if (loadedPin[i] != 0xFF) {
            valid = true;
            break;
        }
    }
    
    if (valid) {
        memcpy(storedPin, loadedPin, BLE_PIN_LENGTH);
        DEBUG_PRINTLN("BLE: PIN loaded from FRAM");
    } else {
        // Use default PIN and save it
        DEBUG_PRINTLN("BLE: No PIN in FRAM, using default");
        ble_setPin(storedPin);  // Save default PIN
    }
}
