/**
 * @file bl_ed25519.c
 * @brief Ed25519 Signature Verification Implementation
 * 
 * Minimal verify-only Ed25519 implementation for bootloader.
 * Based on TweetNaCl and ref10 reference implementations.
 * 
 * This implementation:
 * - Only supports verification (not signing)
 * - Uses ~4KB of code space
 * - No heap allocation
 * - Includes SHA-512 for message hashing
 */

#include "bl_ed25519.h"
#include <string.h>

/* Embedded public key - generated by generate_signing_key.py */
#include "signing_key_pub.h"

/*******************************************************************************
 * SHA-512 Implementation (required for Ed25519)
 ******************************************************************************/

typedef struct {
    uint64_t state[8];
    uint64_t count[2];
    uint8_t buffer[128];
} sha512_ctx_t;

static const uint64_t sha512_k[80] = {
    0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL, 0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL,
    0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL, 0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL,
    0xd807aa98a3030242ULL, 0x12835b0145706fbeULL, 0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL,
    0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL, 0x9bdc06a725c71235ULL, 0xc19bf174cf692694ULL,
    0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL, 0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL,
    0x2de92c6f592b0275ULL, 0x4a7484aa6ea6e483ULL, 0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,
    0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL, 0xb00327c898fb213fULL, 0xbf597fc7beef0ee4ULL,
    0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL, 0x06ca6351e003826fULL, 0x142929670a0e6e70ULL,
    0x27b70a8546d22ffcULL, 0x2e1b21385c26c926ULL, 0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL,
    0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL, 0x81c2c92e47edaee6ULL, 0x92722c851482353bULL,
    0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL, 0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL,
    0xd192e819d6ef5218ULL, 0xd69906245565a910ULL, 0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,
    0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL, 0x2748774cdf8eeb99ULL, 0x34b0bcb5e19b48a8ULL,
    0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL, 0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL,
    0x748f82ee5defb2fcULL, 0x78a5636f43172f60ULL, 0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL,
    0x90befffa23631e28ULL, 0xa4506cebde82bde9ULL, 0xbef9a3f7b2c67915ULL, 0xc67178f2e372532bULL,
    0xca273eceea26619cULL, 0xd186b8c721c0c207ULL, 0xeada7dd6cde0eb1eULL, 0xf57d4f7fee6ed178ULL,
    0x06f067aa72176fbaULL, 0x0a637dc5a2c898a6ULL, 0x113f9804bef90daeULL, 0x1b710b35131c471bULL,
    0x28db77f523047d84ULL, 0x32caab7b40c72493ULL, 0x3c9ebe0a15c9bebcULL, 0x431d67c49c100d4cULL,
    0x4cc5d4becb3e42b6ULL, 0x597f299cfc657e2aULL, 0x5fcb6fab3ad6faecULL, 0x6c44198c4a475817ULL
};

#define ROR64(x, n) (((x) >> (n)) | ((x) << (64 - (n))))
#define CH(x, y, z) (((x) & (y)) ^ (~(x) & (z)))
#define MAJ(x, y, z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
#define SIGMA0(x) (ROR64(x, 28) ^ ROR64(x, 34) ^ ROR64(x, 39))
#define SIGMA1(x) (ROR64(x, 14) ^ ROR64(x, 18) ^ ROR64(x, 41))
#define sigma0(x) (ROR64(x, 1) ^ ROR64(x, 8) ^ ((x) >> 7))
#define sigma1(x) (ROR64(x, 19) ^ ROR64(x, 61) ^ ((x) >> 6))

static uint64_t load64_be(const uint8_t *p) {
    return ((uint64_t)p[0] << 56) | ((uint64_t)p[1] << 48) |
           ((uint64_t)p[2] << 40) | ((uint64_t)p[3] << 32) |
           ((uint64_t)p[4] << 24) | ((uint64_t)p[5] << 16) |
           ((uint64_t)p[6] << 8)  | ((uint64_t)p[7]);
}

static void store64_be(uint8_t *p, uint64_t v) {
    p[0] = (uint8_t)(v >> 56); p[1] = (uint8_t)(v >> 48);
    p[2] = (uint8_t)(v >> 40); p[3] = (uint8_t)(v >> 32);
    p[4] = (uint8_t)(v >> 24); p[5] = (uint8_t)(v >> 16);
    p[6] = (uint8_t)(v >> 8);  p[7] = (uint8_t)v;
}

static void sha512_transform(sha512_ctx_t *ctx, const uint8_t *data) {
    uint64_t a, b, c, d, e, f, g, h, t1, t2, w[80];
    int i;

    for (i = 0; i < 16; i++) {
        w[i] = load64_be(data + i * 8);
    }
    for (i = 16; i < 80; i++) {
        w[i] = sigma1(w[i-2]) + w[i-7] + sigma0(w[i-15]) + w[i-16];
    }

    a = ctx->state[0]; b = ctx->state[1]; c = ctx->state[2]; d = ctx->state[3];
    e = ctx->state[4]; f = ctx->state[5]; g = ctx->state[6]; h = ctx->state[7];

    for (i = 0; i < 80; i++) {
        t1 = h + SIGMA1(e) + CH(e, f, g) + sha512_k[i] + w[i];
        t2 = SIGMA0(a) + MAJ(a, b, c);
        h = g; g = f; f = e; e = d + t1;
        d = c; c = b; b = a; a = t1 + t2;
    }

    ctx->state[0] += a; ctx->state[1] += b; ctx->state[2] += c; ctx->state[3] += d;
    ctx->state[4] += e; ctx->state[5] += f; ctx->state[6] += g; ctx->state[7] += h;
}

static void sha512_init(sha512_ctx_t *ctx) {
    ctx->state[0] = 0x6a09e667f3bcc908ULL;
    ctx->state[1] = 0xbb67ae8584caa73bULL;
    ctx->state[2] = 0x3c6ef372fe94f82bULL;
    ctx->state[3] = 0xa54ff53a5f1d36f1ULL;
    ctx->state[4] = 0x510e527fade682d1ULL;
    ctx->state[5] = 0x9b05688c2b3e6c1fULL;
    ctx->state[6] = 0x1f83d9abfb41bd6bULL;
    ctx->state[7] = 0x5be0cd19137e2179ULL;
    ctx->count[0] = ctx->count[1] = 0;
}

static void sha512_update(sha512_ctx_t *ctx, const uint8_t *data, size_t len) {
    size_t i, index, part_len;

    index = (size_t)((ctx->count[0] >> 3) & 0x7F);
    ctx->count[0] += (uint64_t)len << 3;
    if (ctx->count[0] < ((uint64_t)len << 3)) {
        ctx->count[1]++;
    }
    ctx->count[1] += (uint64_t)len >> 61;

    part_len = 128 - index;
    if (len >= part_len) {
        memcpy(&ctx->buffer[index], data, part_len);
        sha512_transform(ctx, ctx->buffer);
        for (i = part_len; i + 127 < len; i += 128) {
            sha512_transform(ctx, &data[i]);
        }
        index = 0;
    } else {
        i = 0;
    }
    memcpy(&ctx->buffer[index], &data[i], len - i);
}

static void sha512_final(sha512_ctx_t *ctx, uint8_t hash[64]) {
    uint8_t pad[128];
    size_t pad_len, index;
    int i;

    index = (size_t)((ctx->count[0] >> 3) & 0x7F);
    pad_len = (index < 112) ? (112 - index) : (240 - index);

    memset(pad, 0, pad_len);
    pad[0] = 0x80;
    sha512_update(ctx, pad, pad_len);

    store64_be(pad, ctx->count[1]);
    store64_be(pad + 8, ctx->count[0]);
    sha512_update(ctx, pad, 16);

    for (i = 0; i < 8; i++) {
        store64_be(hash + i * 8, ctx->state[i]);
    }
}

__attribute__((unused))
static void sha512(uint8_t hash[64], const uint8_t *data, size_t len) {
    sha512_ctx_t ctx;
    sha512_init(&ctx);
    sha512_update(&ctx, data, len);
    sha512_final(&ctx, hash);
}

/*******************************************************************************
 * Field Arithmetic (mod 2^255 - 19)
 ******************************************************************************/

typedef int64_t fe[16];  /* Field element: 16 limbs of 16 bits each */

static void fe_0(fe h) {
    for (int i = 0; i < 16; i++) h[i] = 0;
}

static void fe_1(fe h) {
    h[0] = 1;
    for (int i = 1; i < 16; i++) h[i] = 0;
}

static void fe_copy(fe h, const fe f) {
    for (int i = 0; i < 16; i++) h[i] = f[i];
}

static void fe_add(fe h, const fe f, const fe g) {
    for (int i = 0; i < 16; i++) h[i] = f[i] + g[i];
}

static void fe_sub(fe h, const fe f, const fe g) {
    for (int i = 0; i < 16; i++) h[i] = f[i] - g[i];
}

static void fe_neg(fe h, const fe f) {
    for (int i = 0; i < 16; i++) h[i] = -f[i];
}

static void fe_carry(fe h) {
    int64_t c;
    for (int i = 0; i < 16; i++) {
        c = (h[i] + (1LL << 15)) >> 16;
        h[i] -= c << 16;
        h[(i + 1) & 15] += c * (i == 15 ? 38 : 1);
    }
}

static void fe_mul(fe h, const fe f, const fe g) {
    int64_t t[31] = {0};
    for (int i = 0; i < 16; i++) {
        for (int j = 0; j < 16; j++) {
            t[i + j] += f[i] * g[j];
        }
    }
    for (int i = 16; i < 31; i++) {
        t[i - 16] += 38 * t[i];
    }
    for (int i = 0; i < 16; i++) h[i] = t[i];
    fe_carry(h);
    fe_carry(h);
}

static void fe_sq(fe h, const fe f) {
    fe_mul(h, f, f);
}

static void fe_invert(fe out, const fe z) {
    fe t0, t1, t2, t3;
    int i;

    fe_sq(t0, z);
    fe_sq(t1, t0);
    fe_sq(t1, t1);
    fe_mul(t1, z, t1);
    fe_mul(t0, t0, t1);
    fe_sq(t2, t0);
    fe_mul(t1, t1, t2);
    fe_sq(t2, t1);
    for (i = 0; i < 4; i++) fe_sq(t2, t2);
    fe_mul(t1, t2, t1);
    fe_sq(t2, t1);
    for (i = 0; i < 9; i++) fe_sq(t2, t2);
    fe_mul(t2, t2, t1);
    fe_sq(t3, t2);
    for (i = 0; i < 19; i++) fe_sq(t3, t3);
    fe_mul(t2, t3, t2);
    fe_sq(t2, t2);
    for (i = 0; i < 9; i++) fe_sq(t2, t2);
    fe_mul(t1, t2, t1);
    fe_sq(t2, t1);
    for (i = 0; i < 49; i++) fe_sq(t2, t2);
    fe_mul(t2, t2, t1);
    fe_sq(t3, t2);
    for (i = 0; i < 99; i++) fe_sq(t3, t3);
    fe_mul(t2, t3, t2);
    fe_sq(t2, t2);
    for (i = 0; i < 49; i++) fe_sq(t2, t2);
    fe_mul(t1, t2, t1);
    fe_sq(t1, t1);
    for (i = 0; i < 4; i++) fe_sq(t1, t1);
    fe_mul(out, t1, t0);
}

static void fe_frombytes(fe h, const uint8_t *s) {
    for (int i = 0; i < 16; i++) {
        h[i] = (int64_t)s[2*i] | ((int64_t)s[2*i + 1] << 8);
    }
    h[15] &= 0x7fff;
}

static void fe_reduce(fe h) {
    int64_t c;
    for (int j = 0; j < 2; j++) {
        for (int i = 0; i < 16; i++) {
            c = (h[i] + (1LL << 15)) >> 16;
            h[i] -= c << 16;
            h[(i + 1) & 15] += c * (i == 15 ? 38 : 1);
        }
    }
    c = h[15] >> 15;
    h[15] &= 0x7fff;
    h[0] += 19 * c;
    c = h[0] >> 16;
    h[0] &= 0xffff;
    h[1] += c;
}

static void fe_tobytes(uint8_t *s, fe h) {
    fe_reduce(h);
    fe_reduce(h);
    
    /* Final reduction */
    int64_t c = (h[0] + 19) >> 16;
    for (int i = 1; i < 15; i++) {
        c = (h[i] + c) >> 16;
    }
    c = (h[15] + c - 0x8000) >> 16;
    c = h[0] + 19 * c;
    h[0] = c & 0xffff;
    c >>= 16;
    for (int i = 1; i < 16; i++) {
        c = h[i] + c;
        h[i] = c & 0xffff;
        c >>= 16;
    }
    
    for (int i = 0; i < 16; i++) {
        s[2*i] = (uint8_t)h[i];
        s[2*i + 1] = (uint8_t)(h[i] >> 8);
    }
}

static int fe_isnegative(const fe f) {
    uint8_t s[32];
    fe t;
    fe_copy(t, f);
    fe_tobytes(s, t);
    return s[0] & 1;
}

static int fe_isnonzero(const fe f) {
    uint8_t s[32];
    fe t;
    fe_copy(t, f);
    fe_tobytes(s, t);
    uint8_t r = 0;
    for (int i = 0; i < 32; i++) r |= s[i];
    return r != 0;
}

/*******************************************************************************
 * Group Element Operations (Edwards curve point)
 ******************************************************************************/

typedef struct {
    fe X, Y, Z, T;
} ge_p3;

typedef struct {
    fe X, Y, Z;
} ge_p2;

typedef struct {
    fe X, Y, Z, T;
} ge_p1p1;

typedef struct {
    fe yplusx, yminusx, xy2d;
} ge_precomp;

typedef struct {
    fe YplusX, YminusX, Z, T2d;
} ge_cached;

/* d = -121665/121666 */
static const fe d = {
    -10913610, 13857413, -15372611, 6949391, 114729,
    -8787816, -6275908, -3247719, -18696448, -12055116,
    -9502083, -11074218, 30846539, 0, 0, 0
};

/* 2*d */
static const fe d2 = {
    -21827239, -5839606, -30745221, 13898782, 229458,
    -17575632, -12551816, -6495438, 29479488, -24110232,
    -19004166, 11076436, -4307158, 0, 0, 0
};

/* sqrt(-1) */
static const fe sqrtm1 = {
    -32595792, -7943725, 9377950, 3500415, 12389472,
    -272473, -25146209, -2005654, 326686, 11406482,
    0, 0, 0, 0, 0, 0
};

__attribute__((unused))
static void ge_p3_0(ge_p3 *h) {
    fe_0(h->X);
    fe_1(h->Y);
    fe_1(h->Z);
    fe_0(h->T);
}

static void ge_p2_0(ge_p2 *h) {
    fe_0(h->X);
    fe_1(h->Y);
    fe_1(h->Z);
}

static void ge_p1p1_to_p2(ge_p2 *r, const ge_p1p1 *p) {
    fe_mul(r->X, p->X, p->T);
    fe_mul(r->Y, p->Y, p->Z);
    fe_mul(r->Z, p->Z, p->T);
}

static void ge_p1p1_to_p3(ge_p3 *r, const ge_p1p1 *p) {
    fe_mul(r->X, p->X, p->T);
    fe_mul(r->Y, p->Y, p->Z);
    fe_mul(r->Z, p->Z, p->T);
    fe_mul(r->T, p->X, p->Y);
}

static void ge_p3_to_cached(ge_cached *r, const ge_p3 *p) {
    fe_add(r->YplusX, p->Y, p->X);
    fe_sub(r->YminusX, p->Y, p->X);
    fe_copy(r->Z, p->Z);
    fe_mul(r->T2d, p->T, d2);
}

static void ge_p3_to_p2(ge_p2 *r, const ge_p3 *p) {
    fe_copy(r->X, p->X);
    fe_copy(r->Y, p->Y);
    fe_copy(r->Z, p->Z);
}

static void ge_p2_dbl(ge_p1p1 *r, const ge_p2 *p) {
    fe t0;
    fe_sq(r->X, p->X);
    fe_sq(r->Z, p->Y);
    fe_sq(r->T, p->Z);
    fe_add(r->T, r->T, r->T);
    fe_add(r->Y, p->X, p->Y);
    fe_sq(t0, r->Y);
    fe_add(r->Y, r->Z, r->X);
    fe_sub(r->Z, r->Z, r->X);
    fe_sub(r->X, t0, r->Y);
    fe_sub(r->T, r->T, r->Z);
}

static void ge_p3_dbl(ge_p1p1 *r, const ge_p3 *p) {
    ge_p2 q;
    ge_p3_to_p2(&q, p);
    ge_p2_dbl(r, &q);
}

static void ge_add(ge_p1p1 *r, const ge_p3 *p, const ge_cached *q) {
    fe t0;
    fe_add(r->X, p->Y, p->X);
    fe_sub(r->Y, p->Y, p->X);
    fe_mul(r->Z, r->X, q->YplusX);
    fe_mul(r->Y, r->Y, q->YminusX);
    fe_mul(r->T, q->T2d, p->T);
    fe_mul(r->X, p->Z, q->Z);
    fe_add(t0, r->X, r->X);
    fe_sub(r->X, r->Z, r->Y);
    fe_add(r->Y, r->Z, r->Y);
    fe_add(r->Z, t0, r->T);
    fe_sub(r->T, t0, r->T);
}

static void ge_sub(ge_p1p1 *r, const ge_p3 *p, const ge_cached *q) {
    fe t0;
    fe_add(r->X, p->Y, p->X);
    fe_sub(r->Y, p->Y, p->X);
    fe_mul(r->Z, r->X, q->YminusX);
    fe_mul(r->Y, r->Y, q->YplusX);
    fe_mul(r->T, q->T2d, p->T);
    fe_mul(r->X, p->Z, q->Z);
    fe_add(t0, r->X, r->X);
    fe_sub(r->X, r->Z, r->Y);
    fe_add(r->Y, r->Z, r->Y);
    fe_sub(r->Z, t0, r->T);
    fe_add(r->T, t0, r->T);
}

static int ge_frombytes_negate_vartime(ge_p3 *h, const uint8_t *s) {
    fe u, v, v3, vxx, check;

    fe_frombytes(h->Y, s);
    fe_1(h->Z);
    fe_sq(u, h->Y);
    fe_mul(v, u, d);
    fe_sub(u, u, h->Z);
    fe_add(v, v, h->Z);

    fe_sq(v3, v);
    fe_mul(v3, v3, v);
    fe_sq(h->X, v3);
    fe_mul(h->X, h->X, v);
    fe_mul(h->X, h->X, u);

    /* h->X = uv^7 */
    /* Now compute uv^7^((q-5)/8) */
    fe t0, t1, t2;
    fe_sq(t0, h->X);
    fe_sq(t1, t0);
    fe_sq(t1, t1);
    fe_mul(t1, h->X, t1);
    fe_mul(t0, t0, t1);
    fe_sq(t0, t0);
    fe_mul(t0, t1, t0);
    fe_sq(t1, t0);
    for (int i = 0; i < 4; i++) fe_sq(t1, t1);
    fe_mul(t0, t1, t0);
    fe_sq(t1, t0);
    for (int i = 0; i < 9; i++) fe_sq(t1, t1);
    fe_mul(t1, t1, t0);
    fe_sq(t2, t1);
    for (int i = 0; i < 19; i++) fe_sq(t2, t2);
    fe_mul(t1, t2, t1);
    for (int i = 0; i < 10; i++) fe_sq(t1, t1);
    fe_mul(t0, t1, t0);
    fe_sq(t1, t0);
    for (int i = 0; i < 49; i++) fe_sq(t1, t1);
    fe_mul(t1, t1, t0);
    fe_sq(t2, t1);
    for (int i = 0; i < 99; i++) fe_sq(t2, t2);
    fe_mul(t1, t2, t1);
    for (int i = 0; i < 50; i++) fe_sq(t1, t1);
    fe_mul(t0, t1, t0);
    fe_sq(t0, t0);
    fe_sq(t0, t0);
    fe_mul(h->X, t0, h->X);

    fe_sq(vxx, h->X);
    fe_mul(vxx, vxx, v);
    fe_sub(check, vxx, u);
    if (fe_isnonzero(check)) {
        fe_add(check, vxx, u);
        if (fe_isnonzero(check)) return -1;
        fe_mul(h->X, h->X, sqrtm1);
    }

    if (fe_isnegative(h->X) == (s[31] >> 7)) {
        fe_neg(h->X, h->X);
    }

    fe_mul(h->T, h->X, h->Y);
    return 0;
}

static void ge_tobytes(uint8_t *s, const ge_p2 *h) {
    fe recip, x, y;
    fe_invert(recip, h->Z);
    fe_mul(x, h->X, recip);
    fe_mul(y, h->Y, recip);
    fe_tobytes(s, y);
    s[31] ^= fe_isnegative(x) << 7;
}

/*******************************************************************************
 * Scalar Operations (mod L where L is the group order)
 ******************************************************************************/

static const uint8_t L[32] = {
    0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,
    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10
};

static void sc_reduce(uint8_t *s) {
    int64_t a[64];
    for (int i = 0; i < 64; i++) a[i] = s[i];
    
    for (int i = 63; i >= 32; i--) {
        int64_t carry = 0;
        for (int j = i - 32; j < i - 12; j++) {
            a[j] += carry - 16 * a[i] * L[j - (i - 32)];
            carry = (a[j] + 128) >> 8;
            a[j] -= carry << 8;
        }
        a[i - 12] += carry;
        a[i] = 0;
    }
    
    int64_t carry = 0;
    for (int i = 0; i < 32; i++) {
        a[i] += carry - (a[31] >> 4) * L[i];
        carry = a[i] >> 8;
        a[i] &= 0xff;
    }
    for (int i = 0; i < 32; i++) {
        a[i] -= carry * L[i];
    }
    for (int i = 0; i < 32; i++) {
        a[i + 1] += a[i] >> 8;
        s[i] = a[i] & 0xff;
    }
}

/*******************************************************************************
 * Double Scalar Multiplication
 ******************************************************************************/

static void slide(int8_t *r, const uint8_t *a) {
    for (int i = 0; i < 256; i++) {
        r[i] = 1 & (a[i >> 3] >> (i & 7));
    }
    for (int i = 0; i < 256; i++) {
        if (r[i]) {
            for (int b = 1; b <= 6 && i + b < 256; b++) {
                if (r[i + b]) {
                    if (r[i] + (r[i + b] << b) <= 15) {
                        r[i] += r[i + b] << b;
                        r[i + b] = 0;
                    } else if (r[i] - (r[i + b] << b) >= -15) {
                        r[i] -= r[i + b] << b;
                        for (int k = i + b; k < 256; k++) {
                            if (!r[k]) {
                                r[k] = 1;
                                break;
                            }
                            r[k] = 0;
                        }
                    } else {
                        break;
                    }
                }
            }
        }
    }
}

/* Base point B */
static const ge_precomp Bi[8] = {
    {{25967493, -14356035, 29566456, 3660896, -12694345, 4014787, 27544626, -11754271, -6079156, 2047605, 0, 0, 0, 0, 0, 0},
     {-12545711, 934262, -2722910, 3049990, -727428, 9406986, 12720692, 5043384, 19500929, -15469378, 0, 0, 0, 0, 0, 0},
     {-8738181, 4489570, 9688441, -14785194, 10184609, -12363380, 29287919, 11864899, -24514362, -4438546, 0, 0, 0, 0, 0, 0}},
    {{15636291, -9688557, 24204773, -7912398, 616977, -16685262, 27787600, -14772189, 28944400, -1550024, 0, 0, 0, 0, 0, 0},
     {16568933, 4717097, -11556148, -1102322, 15682896, -11807043, 16354577, -11775962, 7689662, 11199574, 0, 0, 0, 0, 0, 0},
     {30464156, -5976125, -11779434, -15670865, 23220365, 15915852, 7512774, 10017326, -17749093, -9920357, 0, 0, 0, 0, 0, 0}},
    {{10861363, 11473154, 27284546, 1981175, -30064349, 12577861, 32867885, 14515107, -15438304, 10819380, 0, 0, 0, 0, 0, 0},
     {4708026, 6336745, 20377586, 9066809, -11272109, 6594696, -25653668, 12483688, -12214762, 14791286, 0, 0, 0, 0, 0, 0},
     {-31386186, 11613054, 26821526, 2340713, -30354425, -5765062, -21922475, 6516170, -2510625, 5765892, 0, 0, 0, 0, 0, 0}},
    {{-21744398, -13810475, 1844840, 5021428, -10434399, -15911473, 9716667, 16266922, -5070217, 726099, 0, 0, 0, 0, 0, 0},
     {29370922, -6053998, 7334071, -15342259, 9385287, 2247707, -13661962, -4839461, 30007388, -15823341, 0, 0, 0, 0, 0, 0},
     {-936379, 16086691, 23751945, -543318, -1167538, -5189036, 9137109, 730663, 9835848, 4555336, 0, 0, 0, 0, 0, 0}},
    {{-23376435, 1410446, -22253753, -12899614, 30867635, 15826977, 17693930, 544696, -11985298, 12422646, 0, 0, 0, 0, 0, 0},
     {31117226, -12215734, -13502838, 6561947, -9876867, -12757670, -5118685, -4096706, 29120153, 13924425, 0, 0, 0, 0, 0, 0},
     {-17400879, -14233498, 19946195, -8380824, -32573199, 6920966, -8819557, -1005819, -6355975, 16507039, 0, 0, 0, 0, 0, 0}},
    {{-22635246, 6326646, 3736408, -5765149, -8096368, -10208388, -4182628, 8594841, -13754902, -5765857, 0, 0, 0, 0, 0, 0},
     {-28525028, 8624602, 3495937, -1609993, -6716929, -3635020, -27460464, 3992498, -11191498, -12354190, 0, 0, 0, 0, 0, 0},
     {-11935594, 11354146, -17227206, 2818676, -26894714, -1437595, -1482067, 7279248, 26876491, 6472114, 0, 0, 0, 0, 0, 0}},
    {{2101391, -4930054, 19702731, 2367575, -15427167, 1047675, 5301017, 9328700, 29955601, -11678310, 0, 0, 0, 0, 0, 0},
     {3096359, 9271816, -21620864, -15521844, -14847996, -7592937, -25892142, -12635595, -9917575, 6216608, 0, 0, 0, 0, 0, 0},
     {-32615849, 338663, -25195611, 2510422, -29213566, -13820213, 24822830, -6146567, -26767480, 7525079, 0, 0, 0, 0, 0, 0}},
    {{-23066649, -13985623, 16133487, -7896178, -3389565, 778788, -910336, -2782495, -19386633, 11994101, 0, 0, 0, 0, 0, 0},
     {21691500, -13624626, -641331, -14367021, 3285881, -3483596, -25064666, 9718258, -7477437, 13381418, 0, 0, 0, 0, 0, 0},
     {18445390, -4202236, 14979846, 11622458, -1727110, -3582980, 23111648, -6375247, 28535282, 15779576, 0, 0, 0, 0, 0, 0}}
};

static void ge_madd(ge_p1p1 *r, const ge_p3 *p, const ge_precomp *q) {
    fe t0;
    fe_add(r->X, p->Y, p->X);
    fe_sub(r->Y, p->Y, p->X);
    fe_mul(r->Z, r->X, q->yplusx);
    fe_mul(r->Y, r->Y, q->yminusx);
    fe_mul(r->T, q->xy2d, p->T);
    fe_add(t0, p->Z, p->Z);
    fe_sub(r->X, r->Z, r->Y);
    fe_add(r->Y, r->Z, r->Y);
    fe_add(r->Z, t0, r->T);
    fe_sub(r->T, t0, r->T);
}

static void ge_msub(ge_p1p1 *r, const ge_p3 *p, const ge_precomp *q) {
    fe t0;
    fe_add(r->X, p->Y, p->X);
    fe_sub(r->Y, p->Y, p->X);
    fe_mul(r->Z, r->X, q->yminusx);
    fe_mul(r->Y, r->Y, q->yplusx);
    fe_mul(r->T, q->xy2d, p->T);
    fe_add(t0, p->Z, p->Z);
    fe_sub(r->X, r->Z, r->Y);
    fe_add(r->Y, r->Z, r->Y);
    fe_sub(r->Z, t0, r->T);
    fe_add(r->T, t0, r->T);
}

static void ge_double_scalarmult_vartime(ge_p2 *r, const uint8_t *a, const ge_p3 *A, const uint8_t *b) {
    int8_t aslide[256], bslide[256];
    ge_cached Ai[8];
    ge_p1p1 t;
    ge_p3 u, A2;
    int i;

    slide(aslide, a);
    slide(bslide, b);

    ge_p3_to_cached(&Ai[0], A);
    ge_p3_dbl(&t, A);
    ge_p1p1_to_p3(&A2, &t);
    ge_add(&t, &A2, &Ai[0]); ge_p1p1_to_p3(&u, &t); ge_p3_to_cached(&Ai[1], &u);
    ge_add(&t, &A2, &Ai[1]); ge_p1p1_to_p3(&u, &t); ge_p3_to_cached(&Ai[2], &u);
    ge_add(&t, &A2, &Ai[2]); ge_p1p1_to_p3(&u, &t); ge_p3_to_cached(&Ai[3], &u);
    ge_add(&t, &A2, &Ai[3]); ge_p1p1_to_p3(&u, &t); ge_p3_to_cached(&Ai[4], &u);
    ge_add(&t, &A2, &Ai[4]); ge_p1p1_to_p3(&u, &t); ge_p3_to_cached(&Ai[5], &u);
    ge_add(&t, &A2, &Ai[5]); ge_p1p1_to_p3(&u, &t); ge_p3_to_cached(&Ai[6], &u);
    ge_add(&t, &A2, &Ai[6]); ge_p1p1_to_p3(&u, &t); ge_p3_to_cached(&Ai[7], &u);

    ge_p2_0(r);

    for (i = 255; i >= 0; i--) {
        if (aslide[i] || bslide[i]) break;
    }

    for (; i >= 0; i--) {
        ge_p2_dbl(&t, r);

        if (aslide[i] > 0) {
            ge_p1p1_to_p3(&u, &t);
            ge_add(&t, &u, &Ai[aslide[i] / 2]);
        } else if (aslide[i] < 0) {
            ge_p1p1_to_p3(&u, &t);
            ge_sub(&t, &u, &Ai[(-aslide[i]) / 2]);
        }

        if (bslide[i] > 0) {
            ge_p1p1_to_p3(&u, &t);
            ge_madd(&t, &u, &Bi[bslide[i] / 2]);
        } else if (bslide[i] < 0) {
            ge_p1p1_to_p3(&u, &t);
            ge_msub(&t, &u, &Bi[(-bslide[i]) / 2]);
        }

        ge_p1p1_to_p2(r, &t);
    }
}

/*******************************************************************************
 * Ed25519 Verification
 ******************************************************************************/

bool bl_ed25519_verify(
    const uint8_t signature[64],
    const uint8_t *message,
    size_t message_len,
    const uint8_t public_key[32]
) {
    uint8_t h[64];
    uint8_t rcheck[32];
    ge_p3 A;
    ge_p2 R;
    sha512_ctx_t ctx;

    /* Check signature s < L */
    if (signature[63] & 0xE0) {
        return false;
    }

    /* Decode public key */
    if (ge_frombytes_negate_vartime(&A, public_key) != 0) {
        return false;
    }

    /* h = SHA512(R || A || M) */
    sha512_init(&ctx);
    sha512_update(&ctx, signature, 32);  /* R */
    sha512_update(&ctx, public_key, 32); /* A */
    sha512_update(&ctx, message, message_len);
    sha512_final(&ctx, h);
    sc_reduce(h);

    /* R' = s*B - h*A */
    ge_double_scalarmult_vartime(&R, h, &A, signature + 32);
    ge_tobytes(rcheck, &R);

    /* Verify R == R' */
    uint8_t diff = 0;
    for (int i = 0; i < 32; i++) {
        diff |= signature[i] ^ rcheck[i];
    }
    return diff == 0;
}

bool bl_verify_firmware_signature(
    const uint8_t *firmware,
    size_t firmware_size,
    const uint8_t signature[64]
) {
    return bl_ed25519_verify(signature, firmware, firmware_size, agsys_signing_public_key);
}
